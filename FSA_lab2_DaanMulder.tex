\documentclass[a4paper,12pt]{amsart}

\usepackage[english]{babel}
\usepackage{a4wide}
\usepackage{verbatim}

\makeatletter \def\verbatim@startline{\verbatim@line{\leavevmode\kern20pt\relax}} \makeatother

\begin{document}

\title{Functional Specification of Algorithms, lab exercises week 2}
\author{Daan Mulder, 10279245}
\maketitle
\normalsize

\section*{Mastermind}

For the Mastermind implementation, we use the code given for the lab exercises as-is.
\begin{verbatim}
module Mastermind

where 

import Data.List

data Colour   = Red | Yellow | Blue | Green  | Orange 
                deriving (Eq,Show,Bounded,Enum)

data Answer   = Black | White deriving (Eq,Show)

type Pattern  = [Colour]
type Feedback = [Answer]

samepos :: Pattern -> Pattern -> Int
samepos _      []                 = 0 
samepos []     _                  = 0 
samepos (x:xs) (y:ys) | x == y    = samepos xs ys + 1
                      | otherwise = samepos xs ys 

occurscount ::  Pattern -> Pattern -> Int
occurscount xs []       = 0
occurscount xs (y:ys) 
          | y `elem` xs = occurscount 
                          (delete y xs) ys + 1
          | otherwise   = occurscount xs ys 

reaction :: Pattern -> Pattern -> [Answer]
reaction secret guess = take n (repeat Black) 
                     ++ take m (repeat White)
    where n = samepos secret guess 
          m = occurscount secret guess - n
\end{verbatim}
Then, we define some auxiliary functions that will be used for all exercises. \texttt{makeList} generates all possible combinations of $n$ elements of $xs$. We use \texttt{makeList} to define \texttt{firstList}, which is a list of all possible patterns before the game has started. \texttt{guessing} takes a list $xs$ of possible patterns and returns the subset of that list of patterns that are still possible after guessing $guess$. 
\begin{verbatim}
makeList :: [a] -> Int -> [[a]]
makeList xs 1 = [[x] | x <- xs]
makeList xs n = [[x] ++ y | x <- xs, y <- makeList xs $ n-1]

firstList = makeList [Red,Yellow,Blue,Green,Orange] 4

guessing :: Pattern -> Pattern -> [Pattern] -> [Pattern]
guessing secret guess xs = filter (\x -> reaction x guess
                           == reaction secret guess) xs
\end{verbatim}

\subsection*{Exercise 1}
\texttt{exercise1} takes a pattern and returns the number of guesses it took to guess that pattern (and likewise for every exercise). It uses \texttt{exercise1play} that always guesses the first element of the current list of possible patterns, for which it uses \texttt{guessing} to calculate.
\begin{verbatim}
exercise1play :: Pattern -> [Pattern] -> Int -> Int
exercise1play secret (x:[]) n = if x == secret then n else -1
exercise1play secret (x:xs) n = exercise1play secret
                                (guessing secret x (x:xs)) n+1

exercise1 :: Pattern -> Int
exercise1 secret = exercise1play secret firstList 0
\end{verbatim}

\subsection*{Exercise 2}
For exercise 2 we use the following functions to transform the list of possibilities each round: \texttt{exercise2list} generates a list of tuples that connect each possible guess with a list of feedbacks for every possible secret, then groups each list to obtain the required partition. Then, \texttt{exercise2max} counts the number of elements in each block of the partitions and returns the maximum number for each possible guess. Finally, \texttt{exercise2min} returns the first possible guess that has the minimum number over all possible guesses (this function will be used in other exercises as well).
\begin{verbatim}
exercise2min :: [(Pattern, Int)] -> Pattern
exercise2min xs = fst $ (filter (\ (_,b) -> b
                  == minimum (map snd xs)) xs) !! 0

exercise2max :: [(Pattern, [[Feedback]])] -> [(Pattern, Int)]
exercise2max xs = map (\ (a,b) -> (a,maximum b)) $
                  map (\ (a,b) -> (a,map length b)) xs

exercise2list :: [Pattern] -> [(Pattern, [[Feedback]])]
exercise2list xs = map (\ (a,b) -> (a, group b)) $
                   [(maybeGuess, [reaction maybeSecret maybeGuess |
                   maybeSecret <- xs]) | maybeGuess <- xs]

exercise2play :: Pattern -> [Pattern] -> Int -> Int
exercise2play secret (x:[]) n = if (x == secret) then n else -1
exercise2play secret xs n = exercise2play secret (guessing secret
                            (exercise2min $ exercise2max $ exercise2list xs)
                            xs) n+1

exercise2 :: Pattern -> Int
exercise2 secret = exercise2play secret firstList 0
\end{verbatim}

\subsection*{Exercise 3}
In exercise 3, we use \texttt{exercise3prep} to count the number of blocks of each partition generated by \texttt{exercise2list}. Afterwards, we use \texttt{exercise3max}, which is similar to \texttt{exercise2min} except that it returns the possible guess with the maximum number. 
\begin{verbatim}
exercise3max :: [(Pattern, Int)] -> Pattern
exercise3max xs = fst $ (filter (\ (_,b) -> b == maximum (map snd xs)) xs) !! 0

exercise3prep :: [(Pattern, [[Feedback]])] -> [(Pattern, Int)]
exercise3prep xs = map (\ (a,b) -> (a,length b)) xs

exercise3play :: Pattern -> [Pattern] -> Int -> Int
exercise3play secret (x:[]) n = if (x == secret) then n else -1
exercise3play secret xs n = exercise3play secret (guessing secret (exercise3max $ exercise3prep $ exercise2list xs) xs) n+1

exercise3 :: Pattern -> Int
exercise3 secret = exercise3play secret firstList 0
\end{verbatim}

\subsection*{Exercise 4}
\texttt{exercise4sum} counts the number of elements in each block of the partitions and then takes the sum of the squares. For comparison purposes, it is not necessary to divide by the number of total elements, since it will be the same for each possible guess (namely, the total number of currently possible guesses). Finally, we again use \texttt{exercise2min} to obtain the guess with the minimum number.
\begin{verbatim}
exercise4sum :: [(Pattern, [[Feedback]])] -> [(Pattern, Int)]
exercise4sum xs = map (\ (a,b) -> (a,sum $ map (^2) b)) $ map (\ (a,b) -> (a,map length b)) xs

exercise4play :: Pattern -> [Pattern] -> Int -> Int
exercise4play secret (x:[]) n = if (x == secret) then n else -1
exercise4play secret xs n = exercise4play secret (guessing secret (exercise2min $ exercise4sum $ exercise2list xs) xs) n+1

exercise4 :: Pattern -> Int
exercise4 secret = exercise4play secret firstList 0
\end{verbatim}

\subsection*{Exercise 5}
\texttt{exercise5entropy} counts the number of elements in each block $V_i$ of the partitions and then calculates $\sum \#(V_i) \cdot \log (\#(V_i))$. Again, it is not necessary to divide by the number of total elements, since it is the same for each possible guess. No satisfiable way was found to make the log's base depend on the size of the partition. Then, we use $exercise5min$ to find the minimum, which is similar to \texttt{exercise2min} except that it works with floats.
\begin{verbatim}
exercise5min :: [(Pattern, Float)] -> Pattern
exercise5min xs = fst $ (filter (\ (_,b) -> b == minimum (map snd xs)) xs) !! 0

exercise5entropy :: [(Pattern, [[Feedback]])] -> [(Pattern, Float)]
exercise5entropy xs = map (\ (a,b) -> (a,sum $ map (\ x -> fromIntegral x * (log $ fromIntegral x)) $ b)) $ map (\ (a,b) -> (a,map length b)) xs

exercise5play :: Pattern -> [Pattern] -> Int -> Int
exercise5play secret (x:[]) n = if (x == secret) then n else -1
exercise5play secret xs n = exercise5play secret (guessing secret (exercise5min $ exercise5entropy $ exercise2list xs) xs) n+1

exercise5 :: Pattern -> Int
exercise5 secret = exercise5play secret firstList 0
\end{verbatim}

\subsection*{Exercise 6}
For exercise 6, we implement the Balance game in a similar way to the Mastermind implementation. The secret is a list of $n$ Coins, which can be Light or Normal (Heavy was not implemented to make it easier to avoid situations where several options cannot be distinguished, such as [Light,Normal,Normal] and [Normal,Heavy,Heavy]). Guesses can be made with a list of $n$ scale positions (either left, right or off the scale). \texttt{reaction} then adds the weights for each side (1 for a Light Coin and 2 for a Normal Coin) and gives the appropriate feedback.

Both Knuth's minimax strategy (\texttt{exercise6a}) and the `maximize entropy' strategy (\texttt{exercise6b}) were implemented, though in tests they always behaved the same.
\begin{verbatim}
module Balance

where 

import Data.List
import Debug.Trace
myShow xs = traceShow xs xs 

data Coin = Light | Normal deriving (Eq,Show,Bounded,Enum)
data Feedback = Leftbound | Balanced | Rightbound deriving (Eq,Show)
data ScalePos = L | R | Off deriving (Eq,Show)

type Pattern = [Coin]
type Weighing = [ScalePos]

count :: [Coin] -> Int
count [] = 0
count (x:xs) = if x == Light then 1 + count xs else if x == Normal then 2 + count xs else error "Undefined coin"

gatherSide :: Pattern -> Weighing -> ScalePos -> [Coin]
gatherSide [] [] _ = []
gatherSide (x:xs) (y:ys) side = if y == side then (x:gatherSide xs ys side) else gatherSide xs ys side

reaction :: Pattern -> Weighing -> Feedback
reaction secret guess = if left > right then Leftbound else if left < right then Rightbound else Balanced where {left = count (gatherSide secret guess L); right = count (gatherSide secret guess R)}

makeList :: [a] -> Int -> [[a]]
makeList xs 1 = [[x] | x <- xs]
makeList xs n = [[x] ++ y | x <- xs, y <- makeList xs $ n-1]

guessing :: Pattern -> Weighing -> [Pattern] -> [Pattern]
guessing secret guess xs = filter (\x -> reaction x guess == reaction secret guess) xs


exercise6amin :: [(Weighing, Int)] -> Weighing
exercise6amin xs = fst $ (filter (\ (_,b) -> b == minimum (map snd xs)) xs) !! 0

exercise6amax :: [(Weighing, [[Feedback]])] -> [(Weighing, Int)]
exercise6amax xs = map (\ (a,b) -> (a,maximum b)) $ map (\ (a,b) -> (a,map length b)) xs

exercise6alist :: Int -> [Pattern] -> [(Weighing, [[Feedback]])]
exercise6alist n xs = map (\ (a,b) -> (a, group b)) $ [(maybeGuess, [reaction maybeSecret maybeGuess | maybeSecret <- xs]) | maybeGuess <- makeList [L,R,Off] n]

exercise6aplay :: Int -> Pattern -> [Pattern] -> Int -> Int
exercise6aplay _ secret (x:[]) i = if x == secret then i else -1
exercise6aplay n secret xs i = exercise6aplay n secret (guessing secret (myShow $ exercise6amin $ exercise6amax $ exercise6alist n xs) xs) (i+1)

exercise6a :: Int -> Pattern -> Int
exercise6a n secret = exercise6aplay n secret firstList 0 where firstList = makeList [Light,Normal] n


exercise6bmin :: [(Weighing, Float)] -> Weighing
exercise6bmin xs = fst $ (filter (\ (_,b) -> b == minimum (map snd xs)) xs) !! 0

exercise6bentropy :: [(Weighing, [[Feedback]])] -> [(Weighing, Float)]
exercise6bentropy xs = map (\ (a,b) -> (a,sum $ map (\ x -> fromIntegral x * (log $ fromIntegral x)) $ b)) $ map (\ (a,b) -> (a,map length b)) xs

exercise6bplay :: Int -> Pattern -> [Pattern] -> Int -> Int
exercise6bplay _ secret (x:[]) i = if x == secret then i else -1
exercise6bplay n secret xs i = exercise6bplay n secret (guessing secret (myShow $ exercise6bmin $ exercise6bentropy $ exercise6alist n xs) xs) (i+1)

exercise6b :: Int -> Pattern -> Int
exercise6b n secret = exercise6bplay n secret firstList 0 where firstList = makeList [Light,Normal] n
\end{verbatim}

\end{document}